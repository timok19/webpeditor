"""
This type stub file was generated by pyright.
"""

from typing import Any, Awaitable, Callable, Dict, Iterable, List, Mapping, MutableMapping, Optional, Sequence, Tuple, Type, TypeVar
from aiocache.base import BaseCache
from aiocache.serializers import BaseSerializer
from aiocache.plugins import BasePlugin

logger = ...
F = TypeVar("F", bound=Callable[..., Awaitable[Any]])

class cached:
    """
    Caches the functions return value into a key generated with module_name, function_name
    and args. The cache is available in the function object as ``<function_name>.cache``.

    In some cases you will need to send more args to configure the cache object.
    An example would be endpoint and port for the Redis cache. You can send those args as
    kwargs and they will be propagated accordingly.

    Only one cache instance is created per decorated call. If you expect high concurrency of
    calls to the same function, you should adapt the pool size as needed.

    Extra args that are injected in the function that you can use to control the cache
    behavior are:

        - ``cache_read``: Controls whether the function call will try to read from cache first or
                          not. Enabled by default.
        - ``cache_write``: Controls whether the function call will try to write in the cache once
                           the result has been retrieved. Enabled by default.
        - ``aiocache_wait_for_write``: Controls whether the call of the function will wait for the
                                       value in the cache to be written. If set to False, the write
                                       happens in the background. Enabled by default

    :param ttl: int seconds to store the function call. Default is None which means no expiration.
    :param key: str value to set as key for the function return. Takes precedence over
        key_builder param. If key and key_builder are not passed, it will use module_name
        + function_name + args + kwargs
    :param namespace: string to use as default prefix for the key used in all operations of
        the backend. Default is None
    :param key_builder: Callable that allows to build the function dynamically. It receives
        the function plus same args and kwargs passed to the function.
        This behavior is necessarily different than ``BaseCache.build_key()``
    :param skip_cache_func: Callable that receives the result after calling the
        wrapped function and should return `True` if the value should skip the
        cache (or `False` to store in the cache).
        e.g. to avoid caching `None` results: `lambda r: r is None`
    :param cache: cache class to use when calling the ``set``/``get`` operations.
        Default is :class:`aiocache.SimpleMemoryCache`.
    :param serializer: serializer instance to use when calling the ``dumps``/``loads``.
        If its None, default one from the cache backend is used.
    :param plugins: list plugins to use when calling the cmd hooks
        Default is pulled from the cache class being used.
    :param alias: str specifying the alias to load the config from. If alias is passed, other
        config parameters are ignored. Same cache identified by alias is used on every call. If
        you need a per function cache, specify the parameters explicitly without using alias.
    :param noself: bool if you are decorating a class function, by default self is also used to
        generate the key. This will result in same function calls done by different class instances
        to use different cache keys. Use noself=True if you want to ignore it.
    """
    def __init__(
        self,
        ttl: Optional[float] = ...,
        key: Optional[str] = ...,
        namespace: Optional[str] = ...,
        key_builder: Optional[Callable[[Callable[..., Any], Tuple[Any, ...], Dict[str, Any]], str]] = ...,
        skip_cache_func: Optional[Callable[[Any], bool]] = ...,
        cache: Optional[Type[BaseCache]] = ...,
        serializer: Optional[BaseSerializer] = ...,
        plugins: Optional[Sequence[BasePlugin]] = ...,
        alias: Optional[str] = ...,
        noself: bool = ...,
        **kwargs: Any,
    ) -> None:
        ...

    def __call__(self, f: F) -> F:
        ...

    async def decorator(
        self,
        f: Callable[..., Awaitable[Any]],
        *args: Any,
        cache_read: bool = ...,
        cache_write: bool = ...,
        aiocache_wait_for_write: bool = ...,
        **kwargs: Any,
    ) -> Any:
        ...

    def get_cache_key(self, f: Callable[..., Any], args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> str:
        ...

    async def get_from_cache(self, key: str) -> Any:
        ...

    async def set_in_cache(self, key: str, value: Any) -> None:
        ...



class cached_stampede(cached):
    """
    Caches the functions return value into a key generated with module_name, function_name and args
    while avoids for cache stampede effects.

    In some cases you will need to send more args to configure the cache object.
    An example would be endpoint and port for the Redis cache. You can send those args as
    kwargs and they will be propagated accordingly.

    Only one cache instance is created per decorated function. If you expect high concurrency
    of calls to the same function, you should adapt the pool size as needed.

    :param lease: int seconds to lock function call to avoid cache stampede effects.
        If 0 or None, no locking happens (default is 2). redis and memory backends support
        float ttls
    :param ttl: int seconds to store the function call. Default is None which means no expiration.
    :param key: str value to set as key for the function return. Takes precedence over
        key_from_attr param. If key and key_from_attr are not passed, it will use module_name
        + function_name + args + kwargs
    :param key_from_attr: str arg or kwarg name from the function to use as a key.
    :param namespace: string to use as default prefix for the key used in all operations of
        the backend. Default is None
    :param key_builder: Callable that allows to build the function dynamically. It receives
        the function plus same args and kwargs passed to the function.
        This behavior is necessarily different than ``BaseCache.build_key()``
    :param skip_cache_func: Callable that receives the result after calling the
        wrapped function and should return `True` if the value should skip the
        cache (or `False` to store in the cache).
        e.g. to avoid caching `None` results: `lambda r: r is None`
    :param cache: cache class to use when calling the ``set``/``get`` operations.
        Default is :class:`aiocache.SimpleMemoryCache`.
    :param serializer: serializer instance to use when calling the ``dumps``/``loads``.
        Default is JsonSerializer.
    :param plugins: list plugins to use when calling the cmd hooks
        Default is pulled from the cache class being used.
    :param alias: str specifying the alias to load the config from. If alias is passed,
        other config parameters are ignored. New cache is created every time.
    :param noself: bool if you are decorating a class function, by default self is also used to
        generate the key. This will result in same function calls done by different class instances
        to use different cache keys. Use noself=True if you want to ignore it.
    """
    def __init__(self, lease: Optional[float] = ..., **kwargs: Any) -> None:
        ...

    async def decorator(self, f: Callable[..., Awaitable[Any]], *args: Any, **kwargs: Any) -> Any:
        ...



class multi_cached:
    """
    Only supports functions that return dict-like structures. This decorator caches each key/value
    of the dict-like object returned by the function. The dict keys of the returned data should
    match the set of keys that are passed to the decorated callable in an iterable object.
    The name of that argument is passed to this decorator via the parameter
    ``keys_from_attr``. ``keys_from_attr`` can be the name of a positional or keyword argument.

    If the argument specified by ``keys_from_attr`` is an empty list, the cache will be ignored
    and the function will be called. If only some of the keys in ``keys_from_attr``are cached
    (and ``cache_read`` is True) those values will be fetched from the cache, and only the
    uncached keys will be passed to the callable via the argument specified by ``keys_from_attr``.

    By default, the callable's name and call signature are not incorporated into the cache key,
    so if there is another cached function returning a dict with same keys, those keys will be
    overwritten. To avoid this, use a specific ``namespace`` in each cache decorator or pass a
    ``key_builder``.

    If ``key_builder`` is passed, then the values of ``keys_from_attr`` will be transformed
    before requesting them from the cache. Equivalently, the keys in the dict-like mapping
    returned by the decorated callable will be transformed before storing them in the cache.

    The cache is available in the function object as ``<function_name>.cache``.

    Only one cache instance is created per decorated function. If you expect high concurrency
    of calls to the same function, you should adapt the pool size as needed.

    Extra args that are injected in the function that you can use to control the cache
    behavior are:

        - ``cache_read``: Controls whether the function call will try to read from cache first or
                          not. Enabled by default.
        - ``cache_write``: Controls whether the function call will try to write in the cache once
                           the result has been retrieved. Enabled by default.
        - ``aiocache_wait_for_write``: Controls whether the call of the function will wait for the
                                       value in the cache to be written. If set to False, the write
                                       happens in the background. Enabled by default

    :param keys_from_attr: name of the arg or kwarg in the decorated callable that contains
        an iterable that yields the keys returned by the decorated callable.
    :param namespace: string to use as default prefix for the key used in all operations of
        the backend. Default is None
    :param key_builder: Callable that enables mapping the decorated function's keys to the keys
        used by the cache. Receives a key from the iterable corresponding to
        ``keys_from_attr``, the decorated callable, and the positional and keyword arguments
        that were passed to the decorated callable. This behavior is necessarily different than
        ``BaseCache.build_key()`` and the call signature differs from ``cached.key_builder``.
    :param skip_cache_func: Callable that receives both key and value and returns True
        if that key-value pair should not be cached (or False to store in cache).
        The keys and values to be passed are taken from the wrapped function result.
    :param ttl: int seconds to store the keys. Default is 0 which means no expiration.
    :param cache: cache class to use when calling the ``multi_set``/``multi_get`` operations.
        Default is :class:`aiocache.SimpleMemoryCache`.
    :param serializer: serializer instance to use when calling the ``dumps``/``loads``.
        If its None, default one from the cache backend is used.
    :param plugins: plugins to use when calling the cmd hooks
        Default is pulled from the cache class being used.
    :param alias: str specifying the alias to load the config from. If alias is passed,
        other config parameters are ignored. Same cache identified by alias is used on
        every call. If you need a per function cache, specify the parameters explicitly
        without using alias.
    """
    def __init__(
        self,
        keys_from_attr: str,
        namespace: Optional[str] = ...,
        key_builder: Optional[Callable[[Any, Callable[..., Any], Tuple[Any, ...], Dict[str, Any]], str]] = ...,
        skip_cache_func: Optional[Callable[[Any, Any], bool]] = ...,
        ttl: Optional[float] = ...,
        cache: Optional[Type[BaseCache]] = ...,
        serializer: Optional[BaseSerializer] = ...,
        plugins: Optional[Sequence[BasePlugin]] = ...,
        alias: Optional[str] = ...,
        **kwargs: Any,
    ) -> None:
        ...

    def __call__(self, f: Callable[..., Awaitable[Mapping[Any, Any]]]) -> Callable[..., Awaitable[Mapping[Any, Any]]]:
        ...

    async def decorator(
        self,
        f: Callable[..., Awaitable[Mapping[Any, Any]]],
        *args: Any,
        cache_read: bool = ...,
        cache_write: bool = ...,
        aiocache_wait_for_write: bool = ...,
        **kwargs: Any,
    ) -> Mapping[Any, Any]:
        ...

    def get_cache_keys(self, f: Callable[..., Any], args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> Tuple[List[Any], List[Any], Any]:
        ...

    async def get_from_cache(self, *keys: Any) -> List[Optional[Any]]:
        ...

    async def set_in_cache(
        self,
        result: Mapping[Any, Any],
        fn: Callable[..., Awaitable[Mapping[Any, Any]]],
        fn_args: Tuple[Any, ...],
        fn_kwargs: Dict[str, Any],
    ) -> None:
        ...
