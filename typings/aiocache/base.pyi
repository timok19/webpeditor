"""
This type stub file was generated by pyright.
"""

from types import TracebackType
from typing import Any, Awaitable, Callable, Iterable, List, Literal, Optional, Self, Sequence, Set, Tuple, Type, TypeVar

from aiocache.plugins import BasePlugin
from aiocache.serializers import BaseSerializer

logger = ...
SENTINEL = ...
F = TypeVar("F", bound=Callable[..., Awaitable[Any]])

class API:
    CMDS: Set[Callable[..., object]] = ...
    @classmethod
    def register(cls, func: F) -> F: ...
    @classmethod
    def unregister(cls, func: Callable[..., Awaitable[Any]]) -> None: ...
    @classmethod
    def timeout(cls, func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:
        """
        This decorator sets a maximum timeout for a coroutine to execute. The timeout can be both
        set in the ``self.timeout`` attribute or in the ``timeout`` kwarg of the function call.
        I.e if you have a function ``get(self, key)``, if its decorated with this decorator, you
        will be able to call it with ``await get(self, "my_key", timeout=4)``.

        Use 0 or None to disable the timeout.
        """
        ...

    @classmethod
    def aiocache_enabled(cls, fake_return: Any = ...) -> Callable[[Callable[..., Awaitable[Any]]], Callable[..., Awaitable[Any]]]:
        """
        Use this decorator to be able to fake the return of the function by setting the
        ``AIOCACHE_DISABLE`` environment variable
        """
        ...

    @classmethod
    def plugins(cls, func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]: ...

class BaseCache:
    """
    Base class that agregates the common logic for the different caches that may exist. Cache
    related available options are:

    :param serializer: obj derived from :class:`aiocache.serializers.BaseSerializer`. Default is
        :class:`aiocache.serializers.StringSerializer`.
    :param plugins: list of :class:`aiocache.plugins.BasePlugin` derived classes. Default is empty
        list.
    :param namespace: string to use as default prefix for the key used in all operations of
        the backend. Default is None
    :param key_builder: alternative callable to build the key. Receives the key and the namespace
        as params and should return something that can be used as key by the underlying backend.
    :param timeout: int or float in seconds specifying maximum timeout for the operations to last.
        By default its 5. Use 0 or None if you want to disable it.
    :param ttl: int the expiration time in seconds to use as a default in all operations of
        the backend. It can be overriden in the specific calls.
    """

    NAME: str
    def __init__(
        self,
        serializer: Optional[BaseSerializer] = ...,
        plugins: Optional[Sequence[BasePlugin]] = ...,
        namespace: Optional[str] = ...,
        key_builder: Optional[Callable[[str, Optional[str]], str]] = ...,
        timeout: Optional[float] = ...,
        ttl: Optional[float] = ...,
    ) -> None: ...
    @property
    def serializer(self) -> BaseSerializer: ...
    @serializer.setter
    def serializer(self, value: BaseSerializer) -> None: ...
    @property
    def plugins(self) -> List[BasePlugin]: ...
    @plugins.setter
    def plugins(self, value: Sequence[BasePlugin]) -> None: ...
    @API.register
    @API.aiocache_enabled(fake_return=True)
    @API.timeout
    @API.plugins
    async def add(
        self,
        key: str,
        value: Any,
        ttl: Optional[float] = ...,
        dumps_fn: Optional[Callable[[Any], Any]] = ...,
        namespace: Optional[str] = ...,
        _conn: Any = ...,
    ) -> Literal[True]:
        """
        Stores the value in the given key with ttl if specified. Raises an error if the
        key already exists.

        :param key: str
        :param value: obj
        :param ttl: int the expiration time in seconds. Due to memcached
            restrictions if you want compatibility use int. In case you
            need miliseconds, redis and memory support float ttls
        :param dumps_fn: callable alternative to use as dumps function
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True if key is inserted
        :raises:
            - ValueError if key already exists
            - :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled()
    @API.timeout
    @API.plugins
    async def get(
        self,
        key: str,
        default: Any = ...,
        loads_fn: Optional[Callable[[Any], Any]] = ...,
        namespace: Optional[str] = ...,
        _conn: Any = ...,
    ) -> Optional[Any]:
        """
        Get a value from the cache. Returns default if not found.

        :param key: str
        :param default: obj to return when key is not found
        :param loads_fn: callable alternative to use as loads function
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: obj loaded
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=[])
    @API.timeout
    @API.plugins
    async def multi_get(
        self, keys: Sequence[str], loads_fn: Optional[Callable[[Any], Any]] = ..., namespace: Optional[str] = ..., _conn: Any = ...
    ) -> List[Optional[Any]]:
        """
        Get multiple values from the cache, values not found are Nones.

        :param keys: list of str
        :param loads_fn: callable alternative to use as loads function
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: list of objs
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=True)
    @API.timeout
    @API.plugins
    async def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[float] = ...,
        dumps_fn: Optional[Callable[[Any], Any]] = ...,
        namespace: Optional[str] = ...,
        _cas_token: Any = ...,
        _conn: Any = ...,
    ) -> bool:
        """
        Stores the value in the given key with ttl if specified

        :param key: str
        :param value: obj
        :param ttl: int the expiration time in seconds. Due to memcached
            restrictions if you want compatibility use int. In case you
            need miliseconds, redis and memory support float ttls
        :param dumps_fn: callable alternative to use as dumps function
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True if the value was set
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=True)
    @API.timeout
    @API.plugins
    async def multi_set(
        self,
        pairs: Iterable[Tuple[str, Any]],
        ttl: Optional[float] = ...,
        dumps_fn: Optional[Callable[[Any], Any]] = ...,
        namespace: Optional[str] = ...,
        _conn: Any = ...,
    ) -> Literal[True]:
        """
        Stores multiple values in the given keys.

        :param pairs: list of two element iterables. First is key and second is value
        :param ttl: int the expiration time in seconds. Due to memcached
            restrictions if you want compatibility use int. In case you
            need miliseconds, redis and memory support float ttls
        :param dumps_fn: callable alternative to use as dumps function
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=0)
    @API.timeout
    @API.plugins
    async def delete(self, key: str, namespace: Optional[str] = ..., _conn: Any = ...) -> int:
        """
        Deletes the given key.

        :param key: Key to be deleted
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: int number of deleted keys
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=False)
    @API.timeout
    @API.plugins
    async def exists(self, key: str, namespace: Optional[str] = ..., _conn: Any = ...) -> bool:
        """
        Check key exists in the cache.

        :param key: str key to check
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True if key exists otherwise False
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=1)
    @API.timeout
    @API.plugins
    async def increment(self, key: str, delta: int = ..., namespace: Optional[str] = ..., _conn: Any = ...) -> int:
        """
        Increments value stored in key by delta (can be negative). If key doesn't
        exist, it creates the key with delta as value.

        :param key: str key to check
        :param delta: int amount to increment/decrement
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: Value of the key once incremented. -1 if key is not found.
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        :raises: :class:`TypeError` if value is not incrementable
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=False)
    @API.timeout
    @API.plugins
    async def expire(self, key: str, ttl: int, namespace: Optional[str] = ..., _conn: Any = ...) -> bool:
        """
        Set the ttl to the given key. By setting it to 0, it will disable it

        :param key: str key to expire
        :param ttl: int number of seconds for expiration. If 0, ttl is disabled
        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True if set, False if key is not found
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled(fake_return=True)
    @API.timeout
    @API.plugins
    async def clear(self, namespace: Optional[str] = ..., _conn: Any = ...) -> bool:
        """
        Clears the cache in the cache namespace. If an alternative namespace is given, it will
        clear those ones instead.

        :param namespace: str alternative namespace to use
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: True
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.register
    @API.aiocache_enabled()
    @API.timeout
    @API.plugins
    async def raw(self, command: str, *args: Any, _conn: Any = ..., **kwargs: Any) -> Any:
        """
        Send the raw command to the underlying client. Note that by using this CMD you
        will lose compatibility with other backends.

        Due to limitations with aiomcache client, args have to be provided as bytes.
        For rest of backends, str.

        :param command: str with the command.
        :param timeout: int or float in seconds specifying maximum timeout
            for the operations to last
        :returns: whatever the underlying client returns
        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    @API.timeout
    async def close(self, *args: Any, _conn: Any = ..., **kwargs: Any) -> None:
        """
        Perform any resource clean up necessary to exit the program safely.
        After closing, cmd execution is still possible but you will have to
        close again before exiting.

        :raises: :class:`asyncio.TimeoutError` if it lasts more than self.timeout
        """
        ...

    def get_connection(self) -> _Conn: ...
    async def acquire_conn(self) -> Self: ...
    async def release_conn(self, conn: Any) -> None: ...
    async def __aenter__(self) -> Self: ...
    async def __aexit__(
        self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], tb: Optional[TracebackType]
    ) -> None: ...

class _Conn:
    def __init__(self, cache: BaseCache) -> None: ...
    async def __aenter__(self) -> Self: ...
    async def __aexit__(
        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]
    ) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
